\section{Implementation}
\label{sec:eval}

In this section we describe the design and creation of a basic prototype of our proxy system. Our goal was to implement two different programs. A local proxy that clients of the proxy network make use of, and a server proxy that clients connect to. Both proxies act as SOCKS servers as well as Bitcoin wallets. When the client turns on it discovers a set of active proxy servers, opens payment channels to them, and begins rotating its traffic over the active servers. It gradually pays for traffic as it requests pages. A user makes use of the client by directing their machine to tunnel traffic through the SOCKS server running locally.

\subsection{Dependency Stack}
We locally deployed a large stack of software in order to locally deploy and test our system. For the BitTorrent based discovery system we ran a UDP tracker, UDPT. In order to test local Bitcoin network, we used the Bitcoind utility in regression test mode, which allows you to create and mine on a private block chain locally on your own computer. This allowed us to run all our tests without spending real Bitcoins or waiting for block mining and propagation delays. 

On top of this base layer of infrastructure we assembled our system on top of two distinct projects, Java Socks Proxy Server, a SOCKS 4 and SOCKS 5 proxy server written in Java, and BitcoinJ, a Java implementation of the Bitcoin protocol.

\subsection{Proxy Development}
We began by implementing the pure proxy section of the system without the payment system included. The main section of the program was exactly the same for the client and the server. The only difference being that the server forwards traffic directly to its destination whereas the client chooses a proxy server to tunnel requests through. This was achieved by using the Java class \texttt{ProxySelector}. This allowed us to dynamically decide which proxy to use every time a connection is made to a server. The class nicely encapsulated our code, allowing us to incorporate our client system into any sort of local server or application.

\subsection{Bitcoin Development}
Next we incorporated the Bitcoin part of the system. The BitcoinJ library includes support of Bitcoin micropayment channels which we used for our payment system. Each proxy server runs a Bitcoin payment server. A client opens a Bitcoin payment connection to each server and sends payment each time it requests to load a page. The server blocks each connection until a payment is received, ensuring the content is actually paid for.

\subsection{Discovery Implementations}
Finally we had to implement the discovery methods by which clients can discover servers. We wanted this interface to be very versatile so that multiple discovery methods could be available in different circumstances.

We implemented a very simple UDP BitTorrent client with two functions. It could advertise a peer and request a list of peers. This was used to advertise proxy servers and to list available proxy servers. When our torrent client connects to the tracker and sends an announce request, the request will include a hash of the files the client is seeking. The tracker will then send an announce response to the client with a list of peers who also have that file, based on the info hash given. In our BitTorrent discovery implementation, we created a random ``magic number'' hash that all clients and proxies would announce to a bittorrent tracker. This way the tracker's announce responses will always include the IP addresses and ports of proxies.

Our other discovery service was based around the Bitcoin block chain. Typical transactions describe where the Bitcoins are coming from and where they are going, but transactions that include raw data along with an \texttt{OP\_RETURN} can be filled with 40 bytes of data. Forty bytes of data is sufficient to store an IP address and port number. It would be impractical to interpret every 40 bytes of data on the block chain as an IP address and port (as the 40 bytes could be unrelated data). In order to detect which bytes can be interpreted as IP addresses and ports, proxy hosts will prefix the bytes of the IP address and port they are advertising with a magic number, as in the case of bittorrent. of sufficient length such that it is unlikely that the magic number appears in the normal operation of Bitcoin. Clients download recent blocks from the chain looking for these special transactions and parsing them for server information. By doing this they acquire a set of available proxy servers.
